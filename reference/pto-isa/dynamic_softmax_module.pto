// PTO Module: dynamic_softmax_module
// Generated by PTO ISA Compiler
// Functions: rowmax, rowexpandsub, elem_exp, rowsum, rowexpanddiv, dynamic_softmax
// Entry: @dynamic_softmax

// Function Type: InCore
func @rowmax(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<8x8xf32>
  %result = alloc_tile : !pto.tile<8x1xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %result = trowmax %x : !pto.tile<8x8xf32> -> !pto.tile<8x1xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @rowexpandsub(%input_x: !pto.memref<gm,...,f32>, %input_row: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<8x8xf32>
  %row_vals = alloc_tile : !pto.tile<8x1xf32>
  %result = alloc_tile : !pto.tile<8x8xf32>
  
  // Instructions
  %x = tload %input_x[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %row_vals = tload %input_row[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x1xf32>
  %result = trowexpandsub %x, %row_vals : !pto.tile<8x8xf32>, !pto.tile<8x1xf32> -> !pto.tile<8x8xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @elem_exp(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<8x8xf32>
  %result = alloc_tile : !pto.tile<8x8xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %result = texp %x : !pto.tile<8x8xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @rowsum(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<8x8xf32>
  %result = alloc_tile : !pto.tile<8x1xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %result = trowsum %x : !pto.tile<8x8xf32> -> !pto.tile<8x1xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @rowexpanddiv(%input_x: !pto.memref<gm,...,f32>, %input_row: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<8x8xf32>
  %row_vals = alloc_tile : !pto.tile<8x1xf32>
  %result = alloc_tile : !pto.tile<8x8xf32>
  
  // Instructions
  %x = tload %input_x[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %row_vals = tload %input_row[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x1xf32>
  %result = trowexpanddiv %x, %row_vals : !pto.tile<8x8xf32>, !pto.tile<8x1xf32> -> !pto.tile<8x8xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: Orchestration
func @dynamic_softmax(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>, %temp_rowmax: !pto.memref<gm,...,f32>, %temp_shifted: !pto.memref<gm,...,f32>, %temp_exp: !pto.memref<gm,...,f32>, %temp_rowsum: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  
  // Scalar Declarations
  %total_rows = alloc_scalar : i32
  %tile_rows = alloc_scalar : i32
  %num_full_tiles = alloc_scalar : i32
  %tail_rows = alloc_scalar : i32
  %has_tail = alloc_scalar : u1
  %zero = alloc_scalar : i32
  
  // Instructions
  LI %tile_rows:i32, 8
  LI %zero:i32, 0
  FOR %tile_idx:idx, 0:idx, %num_full_tiles:idx, 1:idx
    CALL @rowmax(%input -> %input, %output -> %temp_rowmax)
    CALL @rowexpandsub(%input_x -> %input, %input_row -> %temp_rowmax, %output -> %temp_shifted)
    CALL @elem_exp(%input -> %temp_shifted, %output -> %temp_exp)
    CALL @rowsum(%input -> %temp_exp, %output -> %temp_rowsum)
    CALL @rowexpanddiv(%input_x -> %temp_exp, %input_row -> %temp_rowsum, %output -> %output)
  ENDFOR
  CMP %has_tail:u1, %tail_rows:i32, %zero:i32, GT
  IF %has_tail:u1
    CALL @rowmax(%input -> %input, %output -> %temp_rowmax)
    CALL @rowexpandsub(%input_x -> %input, %input_row -> %temp_rowmax, %output -> %temp_shifted)
    CALL @elem_exp(%input -> %temp_shifted, %output -> %temp_exp)
    CALL @rowsum(%input -> %temp_exp, %output -> %temp_rowsum)
    CALL @rowexpanddiv(%input_x -> %temp_exp, %input_row -> %temp_rowsum, %output -> %output)
  ENDIF
  
  return
}
